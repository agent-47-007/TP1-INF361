Question 1 : Décrire la procédure correcte pour modifier la configuration du service SSH

Procédure complète étape par étape :

Étape 1 : Créer une sauvegarde du fichier de configuration
sudo cp /etc/ssh/sshd_config /etc/ssh/sshd_config.backup.20251203_194700

Pourquoi ? En cas d'erreur, on peut restaurer rapidement la configuration fonctionnelle.

Étape 2 : Ouvrir une session SSH supplémentaire (CRITIQUE)
Avant toute modification, on ouvre une deuxième session SSH dans un autre terminal. 
Cette session de secours nous permettra de corriger les erreurs si la première session se déconnecte.

Étape 3 : Modifier le fichier de configuration

sudo nano /etc/ssh/sshd_config
# ou
sudo vim /etc/ssh/sshd_config

Étape 4 : Vérifier la syntaxe du fichier de configuration (ESSENTIEL)
sudo sshd -t


Étape 5 : Recharger le service SSH (PAS restart)
sudo systemctl reload sshd
# ou sur certains systèmes
sudo systemctl reload ssh

Étape 6 : Tester la nouvelle configuration
Dans votre deuxième session SSH (celle de secours), testez la connexion :
ssh -p NOUVEAU_PORT user@serveur

Étape 7 : Vérifier que le service fonctionne correctement

sudo systemctl status sshd
Vérifiez également les logs en temps réel :
sudo tail -f /var/log/auth.log


Étape 8 : Une fois la connexion confirmée
On peut fermer les anciennes sessions SSH. 
Bien vouloir garder toujours au moins une session active jusqu'à confirmation complète.

Question 2 : Expliquer le principal risque encouru si cette procédure n'est pas respectée

Le risque majeur : PERTE TOTALE D'ACCÈS AU SERVEUR

Scénario catastrophe détaillé :
Situation 1 : Redémarrage au lieu de rechargement

# MAUVAISE PRATIQUE ❌
sudo systemctl restart sshd

Conséquence : Si la configuration contient une erreur :
Toutes les connexions SSH actives sont coupées immédiatement
Le service SSH ne redémarre pas à cause de l'erreur
Vous êtes définitivement bloqué hors du serveur
Solution : Accès physique au serveur ou console de récupération (si VPS : console web du fournisseur)

Situation 2 : Pas de vérification de syntaxe

# Modification avec une faute de frappe
Port 22222222222  # Port invalide

PermitRootLogin yse  # Faute de frappe (au lieu de "yes")

Sans sshd -t, ces erreurs ne sont détectées qu'au redémarrage, provoquant un échec du service.
Situation 3 : Pas de session de secours Si vous modifiez le port SSH de 22 à 2222 et rechargez sans tester depuis une autre session :
Votre session actuelle reste connectée (elle utilise encore l'ancien port)
Vous pensez que tout fonctionne
Vous vous déconnectez
IMPOSSIBLE de se reconnecter car vous essayez le port 22 qui n'écoute plus
Autres risques secondaires :
Perte de données en cours de transfert


Si des transferts SCP/SFTP sont en cours, ils seront interrompus
Interruption de services


Les scripts automatisés utilisant SSH échoueront
Les sauvegardes distantes seront interrompues
Verrouillage accidentel


Exemple : PermitRootLogin no alors que root est le seul utilisateur
AllowUsers bob alors que vous êtes connecté en tant que alice
Coûts financiers


Sur un VPS cloud, l'accès à la console de récupération peut être payant
Temps d'indisponibilité du service
Estimation du temps de récupération :
Avec console de récupération : 30-60 minutes
Sans console (serveur physique distant) : Plusieurs heures à plusieurs jours
Dans le pire cas : Réinstallation complète du système

Question 3 : Citer et justifier au moins cinq paramètres de sécurité du serveur SSH

Je vais vous présenter 7 paramètres essentiels (vous devez en choisir au moins 5) avec justifications détaillées.

Paramètre 1 : PermitRootLogin

# Dans /etc/ssh/sshd_config
PermitRootLogin no

Justification détaillée :
Risque : Le compte root est la cible n°1 des attaques par force brute car :

Son nom est connu (toujours "root")
Il a tous les privilèges
Les attaquants n'ont qu'à deviner le mot de passe
Impact de l'attaque : Si un attaquant obtient l'accès root, il contrôle totalement le système :


Installation de backdoors
Vol de données
Destruction du système
Utilisation du serveur pour des activités malveillantes

Bonne pratique :

Créer un utilisateur standard avec des privilèges sudo
Se connecter d'abord avec cet utilisateur
Utiliser sudo pour les commandes nécessitant des privilèges

Exemple de logs d'attaque :
Failed password for root from 192.168.1.100 port 45678 ssh2
Failed password for root from 192.168.1.100 port 45679 ssh2
Failed password for root from 192.168.1.100 port 45680 ssh2


Paramètre 2 : Port
# Dans /etc/ssh/sshd_config
Port 2222

Justification détaillée :
Risque : Le port 22 est scanné en permanence par des bots automatisés :

Shodan et autres moteurs de recherche indexent les ports 22 ouverts
Des millions de tentatives de connexion automatiques chaque jour
Scripts Kiddies et botnets ciblent massivement le port par défaut
Réduction des attaques : Selon des études, changer le port réduit de 90-95% les tentatives d'intrusion automatisées


Statistiques réelles :

Port 22 : ~5000 tentatives de connexion/jour
Port 2222 : ~50 tentatives de connexion/jour

Choix du port :

Évitez les ports 1-1023 (privilégiés, nécessitent root)
Choisissez entre 1024-65535

Évitez les ports courants : 8080, 3306, 5432
Exemple recommandé : 2222, 2200, 22000
⚠️ Attention : Ce n'est pas une sécurité absolue, mais une couche supplémentaire ("security by obscurity")

Paramètre 3 : PasswordAuthentication

# Dans /etc/ssh/sshd_config
PasswordAuthentication no
PubkeyAuthentication yes

Justification détaillée :
Faiblesse des mots de passe :

Vulnérables aux attaques par dictionnaire
Vulnérables aux attaques par force brute
Peuvent être compromis (phishing, keyloggers)
Souvent réutilisés sur plusieurs services
Force des clés SSH :

Clé RSA 4096 bits ≈ équivalent à un mot de passe de 600+ caractères
Impossible à deviner par force brute
Stockée localement, jamais transmise sur le réseau
Peut être protégée par une passphrase
Comparaison temps de crack :
Mot de passe 8 caractères complexe : quelques heures à quelques jours
Clé RSA 2048 bits : plusieurs milliards d'années
Clé RSA 4096 bits : impossible avec la technologie actuelle

Procédure de mise en place :
# 1. Générer une paire de clés (côté client)
ssh-keygen -t rsa -b 4096 -C "votre_email@example.com"

# 2. Copier la clé publique sur le serveur
ssh-copy-id -p PORT user@serveur

# 3. Tester la connexion avec la clé
ssh -p PORT user@serveur

# 4. SEULEMENT APRÈS confirmation, désactiver les mots de passe
PasswordAuthentication no


Paramètre 4 : MaxAuthTries
# Dans /etc/ssh/sshd_config
MaxAuthTries 3

Justification détaillée :
Valeur par défaut : 6 tentatives (trop permissif)


Attaques par force brute :


Les bots testent des milliers de mots de passe
Chaque tentative supplémentaire augmente les chances de succès
Limiter à 3 tentatives réduit drastiquement l'efficacité des attaques
Calcul probabiliste :

Avec 6 tentatives : probabilité de succès × 2
Avec 3 tentatives : probabilité réduite de moitié
Avec 1 tentative : quasiment impossible


Expérience utilisateur :

3 tentatives suffisent largement pour un utilisateur légitime
En cas d'erreur, attendre quelques secondes et réessayer

Complément recommandé : Fail2Ban
# Installer Fail2Ban pour bannir temporairement après échecs
sudo apt-get install fail2ban

# Configuration pour SSH
# Bannir pendant 10 minutes après 3 échecs


Paramètre 5 : Protocol
# Dans /etc/ssh/sshd_config
Protocol 2

Justification détaillée :
SSH Protocol 1 (obsolète) :

Vulnérabilités cryptographiques connues et exploitables
Failles de sécurité : insertion de commandes, attaques man-in-the-middle
Algorithmes de chiffrement faibles (DES, 3DES)
Publié en 1995, abandonné officiellement
SSH Protocol 2 (moderne) :

Publié en 2006, constamment mis à jour
Chiffrement fort : AES-256, ChaCha20
Protection contre les attaques par rejeu
Intégrité des données avec HMAC
Échange de clés Diffie-Hellman
Note : Sur les versions récentes d'OpenSSH (7.0+), le Protocol 1 n'est même plus supporté, ce paramètre n'est donc plus nécessaire. Mais pour les anciens systèmes, c'est crucial.

Paramètre 6 : AllowUsers / AllowGroups
# Dans /etc/ssh/sshd_config
AllowUsers alice bob charlie
# OU
AllowGroups ssh-users

Justification détaillée :
Principe du moindre privilège :


Par défaut, TOUS les utilisateurs du système peuvent se connecter en SSH
Cela inclut les comptes de service (www-data, mysql, etc.)
Limiter explicitement qui peut se connecter réduit la surface d'attaque
Avantage de AllowGroups :

 # Créer un groupe dédié SSH
sudo groupadd ssh-users

# Ajouter les utilisateurs autorisés
sudo usermod -aG ssh-users alice
sudo usermod -aG ssh-users bob

# Dans sshd_config
AllowGroups ssh-users


Cas d'utilisation réel :


Serveur avec 50 comptes utilisateurs
Seulement 5 administrateurs ont besoin d'accès SSH
Les 45 autres utilisateurs n'ont besoin que de services web/FTP
Alternative : DenyUsers / DenyGroups
# Interdire spécifiquement certains utilisateurs
DenyUsers www-data mysql nobody


Paramètre 7 : ClientAliveInterval et ClientAliveCountMax
# Dans /etc/ssh/sshd_config
ClientAliveInterval 300
ClientAliveCountMax 2

Justification détaillée :
Risque des sessions inactives :


Un utilisateur part en réunion, laisse sa session ouverte
Un collègue ou attaquant peut accéder à la machine
Les sessions zombie consomment des ressources
Fonctionnement :


ClientAliveInterval 300 : envoie un message au client toutes les 5 minutes (300 secondes)
ClientAliveCountMax 2 : attend 2 réponses manquées
Déconnexion après : 300 × 2 = 600 secondes = 10 minutes d'inactivité
Calcul du timeout :

 Timeout total = ClientAliveInterval × ClientAliveCountMax

Exemples :
300 × 2 = 600s (10 min) - recommandé pour la production
600 × 1 = 600s (10 min) - alternative
1800 × 2 = 3600s (60 min) - pour les environnements de développement


Impact sur la sécurité :


Réduit le risque de "session hijacking"
Force les utilisateurs à se reconnecter régulièrement
Libère les ressources serveur
